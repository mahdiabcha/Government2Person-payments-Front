import { Component, forwardRef, Input, OnChanges, SimpleChanges, signal, effect } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, NG_VALUE_ACCESSOR, ControlValueAccessor } from '@angular/forms';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';

@Component({
  selector: 'app-json-editor',
  standalone: true,
  imports: [CommonModule, FormsModule, MatFormFieldModule, MatInputModule, MatButtonModule],
  providers: [{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => JsonEditorComponent),
    multi: true
  }],
  template: `
    <div class="grid gap-2">
      <mat-form-field appearance="outline" class="w-full">
        <mat-label>{{label || 'JSON'}}</mat-label>
        <textarea matInput
                  rows="14"
                  [ngModel]="text()"
                  (ngModelChange)="onTextChange($event)"
                  spellcheck="false"
                  style="font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;"></textarea>
      </mat-form-field>

      <div class="flex gap-2">
        <button mat-stroked-button (click)="format()">Format</button>
        <button mat-stroked-button color="warn" (click)="minify()">Minify</button>
        <span class="text-sm" [style.color]="valid() ? '#4caf50' : '#f44336'">
          {{ valid() ? '✓ valid JSON' : '✗ invalid JSON (saved as plain text)' }}
        </span>
      </div>
    </div>
  `
})
export class JsonEditorComponent implements ControlValueAccessor, OnChanges {
  @Input() label?: string;

  private _value = '';
  text = signal<string>('');
  valid = signal<boolean>(true);

  private onChange: (v: string) => void = () => {};
  private onTouched: () => void = () => {};

  ngOnChanges(_: SimpleChanges) {
    // noop – all updates come via writeValue
  }

  writeValue(v: string | null | undefined): void {
    const incoming = (v ?? '').toString();
    this._value = incoming;
    this.text.set(incoming);
    this.valid.set(this._isValidJson(incoming));
  }

  registerOnChange(fn: (v: string) => void): void { this.onChange = fn; }
  registerOnTouched(fn: () => void): void { this.onTouched = fn; }
  setDisabledState?(isDisabled: boolean): void { /* optional */ }

  onTextChange(v: string) {
    this.text.set(v);
    this.valid.set(this._isValidJson(v));
    this._value = v;
    this.onChange(v);
  }

  format() {
    const raw = this.text();
    try {
      const pretty = JSON.stringify(JSON.parse(raw || '{}'), null, 2);
      this.text.set(pretty);
      this.valid.set(true);
      this.onChange(pretty);
    } catch {
      // keep as-is if invalid
      this.valid.set(false);
    }
  }

  minify() {
    const raw = this.text();
    try {
      const min = JSON.stringify(JSON.parse(raw || '{}'));
      this.text.set(min);
      this.valid.set(true);
      this.onChange(min);
    } catch {
      this.valid.set(false);
    }
  }

  private _isValidJson(s: string): boolean {
    if (!s?.trim()) return true;
    try { JSON.parse(s); return true; } catch { return false; }
  }
}
